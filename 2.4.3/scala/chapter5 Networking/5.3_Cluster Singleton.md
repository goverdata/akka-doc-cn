＃5.3 Cluster Singleton

对于一些使用情况，它是方便的，有时也是强制性的，以确保您有一个特定类型的某个actor运行在集群中的某个地方。

一些例子：

* 某些全集团一致决策的单一责任点，或跨集群系统的行动协调
* 单入口点到外部系统
* 单主，很多工人
* 集中式命名服务或路由逻辑

使用单例不应该是第一个设计选择。它有几个缺点，如单点的瓶颈。单点故障也是一个相关的问题，但在某些情况下，此功能通过确保另一个单例实例将最终启动来处理。

集群单例模式由`akka.cluster.singleton.ClusterSingletonManager`实现。它在所有集群节点或标记有特定角色的一组节点之间管理一个单例子actor实例。 `ClusterSingletonManager`是一个actor，应该在集群中的所有节点或所有具有指定角色的节点上启动。实际的singleton actor由最早节点上的ClusterSingletonManager启动，通过从提供的Props创建一个子actor。 `ClusterSingletonManager`确保至多一个单例实例在任何时间点运行。

singleton actor总是在具有指定角色的最旧成员上运行。最旧的成员由`akka.cluster.Member＃isOlderThan`确定。从集群中删除该成员时，可能会发生更改。请注意，在切换过程中没有活动单例的时间段很短。

集群故障检测器将注意到最旧的节点由于诸如JVM崩溃，硬关闭或网络故障等原因而不可达时。然后一个新的最老的节点将接管并创建一个新的单例子actor。对于这些故障情况，将不会有一个优雅的切换，但是通过一切合理的手段阻止了多个活动单例。一些角落案例最终通过可配置的超时来解决。

您可以通过使用提供的`akka.cluster.singleton.ClusterSingletonProxy`来访问singleton actor，这将把所有消息路由到singleton的当前实例。代理将跟踪集群中最早的节点，并通过显式发送单例的actorSelection“akka.actor.Identify”消息并等待它回复来解析单例的ActorRef。如果单例在特定（可配置）时间内没有回复，则定期执行此操作。给定实现，可能存在ActorRef不可用的时间段，例如，当节点离开集群时。在这些情况下，代理将缓冲发送到单例的消息，然后在单例最终可用时传递它们。如果缓冲区已满，则当通过代理发送新消息时，`ClusterSingletonProxy`将删除旧消息。缓冲区的大小是可配置的，可以通过使用缓冲区大小0禁用。

值得注意的是，由于这些参与者的分布式性质，消息总是可能丢失。和往常一样，应该在单例（确认）和客户端（重试）actor中实现附加逻辑，以确保至少一次消息传递。

如果启用了该特性，则单例实例将不会在状态为WeaklyUp的成员上运行。

## 5.3.1 需要注意的潜在问题

这种模式似乎很诱人，最初使用，但它有几个缺点，其中一些列举如下：

*集群单体可能很快成为性能瓶颈，
*你不能依赖集群单例是不停的可用 - 例如。当单例已经在其上运行的节点死亡时，将花费几秒钟来注意到这一点，并且单例被迁移到另一个节点，
*在网络分区出现在使用自动降级的群集（参见自动降级文档自动降级与手动降级）的情况下，可能会发生孤立的群集每个都决定启动自己的单例，意味着可能是在系统中运行的多个单例，但是集群没有办法找出它们（因为分区）。

特别是最后一点是你应该注意的 - 一般来说，当使用Cluster Singleton模式时，你应该自己处理downing节点，而不依赖于基于时序的自动关闭功能。

>警告：使用Cluster Singleton和Automatic Downing时要非常小心，因为它允许集群分成两个独立的集群，这反过来会导致多个Singleton被启动，每个独立的集群中有一个！

## 5.3.2 例子

假设我们需要一个单一的入口点到外部系统。从JMS队列接收消息的actor，严格要求只有一个JMS消费者必须存在才能确保消息按顺序处理。这可能不是一个人想要设计的东西，而是一个典型的现实世界的情况下，当与外部系统集成。

在集群中的每个节点上，您需要启动ClusterSingletonManager并提供单例程序的Props，在这种情况下是JMS队列消费者。

```scala
system.actorOf（
ClusterSingletonManager.props（
singletonProps =
Props（classOf [Consumer]，queue，testActor），
terminationMessage = End，
settings = ClusterSingletonManagerSettings（system）.withRole（“worker”）
），
name =“consumer”
）
```

这里我们将singleton限制为以“worker”角色标记的节点，但是所有节点，独立于角色，可以通过不指定withRole使用。

这里我们使用一个应用程序特定的terminationMessage能够在实际停止单例actor之前关闭资源。注意，PoisonPill是一个完美的terminateMessage，如果你只需要停止actor。

下面是单例动作者如何处理这个例子中的terminationMessage。

```scala
case结束⇒
   排队！取消注册消费者
case unregistrationOk⇒
   stopsBeforeUnregistration = false
   上下文停止自我
case ping⇒sender（）！乒乓
```

使用上面给出的名称，可以使用正确配置的代理从任何集群节点获取单例的访问。

```scala
system.actorOf（
ClusterSingletonProxy.props（
singletonManagerPath =“/ user / consumer”，
settings = ClusterSingletonProxySettings（system）.withRole（“worker”）
），
name =“consumerProxy”
）
```
在Typesafe Activator教程中有一个更全面的示例，名为分布式工作者与Akka和Scala !.

## 5.3.3依赖

要使用Cluster Singleton，您必须在项目中添加以下依赖项。

sbt：

```sbt
“com.typesafe.akka”%%“akka-cluster-tools”％“2.4.1”
```

maven：

```xml
<dependency>
<groupId> com.typesafe.akka </ groupId>
<artifactId> akka-cluster-tools_2.11 </ artifactId>
<version> 2.4.1 </ version>
</ dependency>
```

## 5.3.4配置

当使用ActorSystem参数创建时，以下配置属性由ClusterSingletonManagerSettings读取。还可以修改ClusterSingletonManagerSettings或从另一个具有与下面相同布局的配置节创建它。 ClusterSingletonManagerSettings是ClusterSingletonManager.props工厂方法的参数，即每个单例可以根据需要配置不同的设置。

```sbt
akka.cluster.singleton {
＃子单体actor的actor名称。
singleton-name =“singleton”

＃Singleton在用指定角色标记的节点之间。
＃如果未指定角色，则它是集群中所有节点之间的单例。
role =“”

＃当节点变得最老时，它向先前的最旧节点发送切换请求，
＃可能离开集群。这将重试与此间隔，直到
＃以前最老的确认移交已经开始或前一个
＃oldest成员从集群中删除（+ akka.cluster.down-removal-margin）。
hand-over-retry-interval = 1s

＃重试次数来自hand-over-retry-interval和
＃akka.cluster.down-removal-margin（或ClusterSingletonManagerSettings.removalMargin），
＃但它永远不会小于此属性。
min-number-of-hand-over-retries = 10
}}
```
当使用ActorSystem参数创建时，以下配置属性由ClusterSingletonProxySettings读取。还可以修改ClusterSingletonProxySettings或从具有与下面相同布局的另一个配置节创建它。 ClusterSingletonProxySettings是ClusterSingletonProxy.props工厂方法的参数，即每个单例代理可以根据需要配置不同的设置。

```sbt
akka.cluster.singleton-proxy {
＃由ClusterSingletonManager启动的singleton actor的actor名称singleton-name = $ {akka.cluster.singleton.singleton-name}

＃可以部署单例的集群节点的角色。
＃如果未指定角色，则任何节点将执行。
role =“”

＃代理将尝试解析单例实例的时间间隔。
singleton-identification-interval = 1s

＃如果单例的位置未知，代理将缓冲这个
＃number of messages and deliver them when the singleton is identified。
＃当缓冲区已满时，当有新消息时，旧消息将被删除
＃通过代理发送。
＃使用0禁用缓冲，即，如果消息立即丢弃
＃单位的位置是未知的。
＃最大允许缓冲区大小为10000。
buffer-size = 1000
}}
```

