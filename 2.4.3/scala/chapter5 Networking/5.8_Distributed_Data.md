#5.8 Distributed Data

Akka Distributed Data is useful when you need to share data between nodes in an Akka Cluster. The data is accessed with an actor providing a key-value store like API. The keys are unique identifiers with type information of the data values. The values are Conflict Free Replicated Data Types (CRDTs).

All data entries are spread to all nodes, or nodes with a certain role, in the cluster via direct replication and gossip based dissemination. You have fine grained control of the consistency level for reads and writes.

The nature CRDTs makes it possible to perform updates from any node without coordination. Concurrent updates from different nodes will automatically be resolved by the monotonic merge function, which all data types must provide. The state changes always converge. Several useful data types for counters, sets, maps and registers are provided and you can also implement your own custom data types.

It is eventually consistent and geared toward providing high read and write availability (partition tolerance), with low latency. Note that in an eventually consistent system a read may return an out-of-date value.

Warning: This module is marked as “experimental” as of its introduction in Akka 2.4.0. We will continue to improve this API based on our users’ feedback, which implies that while we try to keep incompatible changes to a minimum the binary compatibility guarantee for maintenance releases does not apply to the contents of the akka.persistence package.

##5.8.1 Using the Replicator

The akka.cluster.ddata.Replicator actor provides the API for interacting with the data. The Replicator actor must be started on each node in the cluster, or group of nodes tagged with a specific role. It communicates with other Replicator instances with the same path (without address) that are running on other nodes . For convenience it can be used with the akka.cluster.ddata.DistributedData extension.

Cluster members with status WeaklyUp, if that feature is enabled, will currently not participate in Distributed Data, but that is something that should be possible to add in a future release.

Below is an example of an actor that schedules tick messages to itself and for each tick adds or removes elements from a ORSet (observed-remove set). It also subscribes to changes of this.

```scala
import java.util.concurrent.ThreadLocalRandom 
import akka.actor.Actor 
import akka.actor.ActorLogging 
import akka.cluster.Cluster 
import akka.cluster.ddata.DistributedData 
import akka.cluster.ddata.ORSet 
import akka.cluster.ddata.ORSetKey 
import akka.cluster.ddata.Replicator 
import akka.cluster.ddata.Replicator._

object DataBot {
	private case object Tick 
}

class DataBot extends Actor with ActorLogging { 
	import DataBot._
	
	val replicator = DistributedData(context.system).replicator 
	implicit val node = Cluster(context.system)
	
	import context.dispatcher 
	val tickTask = context.system.scheduler.schedule(5.seconds, 5.seconds, self, Tick)
	
	val DataKey = ORSetKey[String]("key")
	
	replicator ! Subscribe(DataKey, self)
	
	def receive = { 
	case Tick => val s = ThreadLocalRandom.current().nextInt(97, 123).toChar.toString if (ThreadLocalRandom.current().nextBoolean()) { // add log.info("Adding: {}", s) replicator ! Update(DataKey, ORSet.empty[String], WriteLocal)(_ + s) } else { // remove log.info("Removing: {}", s) replicator ! Update(DataKey, ORSet.empty[String], WriteLocal)(_ - s) }
	
	case _: UpdateResponse[_] => // ignore
	
	case c @ Changed(DataKey) => val data = c.get(DataKey) log.info("Current elements: {}", data.elements)
	
	}
	
	override def postStop(): Unit = tickTask.cancel()
}
```
Update

To modify and replicate a data value you send a Replicator.Update message to the local Replicator. The current data value for the key of the Update is passed as parameter to the modify function of the Update. The function is supposed to return the new value of the data, which will then be replicated according to the given consistency level. The modify function is called by the Replicator actor and must therefore be a pure function that only uses the data parameter and stable fields from enclosing scope. It must for example not access sender() reference of an enclosing actor. Update is intended to only be sent from an actor running in same local ActorSystem as

• the Replicator, because the modify function is typically not serializable. You supply a write consistency level which has the following meaning: • WriteLocal the value will immediately only be written to the local replica, and later disseminated with gossip • WriteTo(n) the value will immediately be written to at least n replicas, including the local replica • WriteMajority the value will immediately be written to a majority of replicas, i.e. at least N/2 + 1 replicas, where N is the number of nodes in the cluster (or cluster role group) • WriteAll the value will immediately be written to all nodes in the cluster (or all nodes in the cluster role group)


```scala
implicit val node = Cluster(system) val replicator = DistributedData(system).replicator

val Counter1Key = PNCounterKey("counter1") val Set1Key = GSetKey[String]("set1") val Set2Key = ORSetKey[String]("set2") val ActiveFlagKey = FlagKey("active")

replicator ! Update(Counter1Key, PNCounter(), WriteLocal)(_ + 1)

val writeTo3 = WriteTo(n = 3, timeout = 1.second) replicator ! Update(Set1Key, GSet.empty[String], writeTo3)(_ + "hello")

val writeMajority = WriteMajority(timeout = 5.seconds) replicator ! Update(Set2Key, ORSet.empty[String], writeMajority)(_ + "hello")

val writeAll = WriteAll(timeout = 5.seconds) replicator ! Update(ActiveFlagKey, Flag.empty, writeAll)(_.switchOn)
```
As reply of the Update a Replicator.UpdateSuccess is sent to the sender of the Update if the value was successfully replicated according to the supplied consistency level within the supplied timeout. Otherwise a Replicator.UpdateFailure subclass is sent back. Note that a Replicator.UpdateTimeout reply does not mean that the update completely failed or was rolled back. It may still have been replicated to some nodes, and will eventually be replicated to all nodes with the gossip protocol.

case UpdateSuccess(Counter1Key, req) => // ok

case UpdateSuccess(Set1Key, req) => // ok case UpdateTimeout(Set1Key, req) => // write to 3 nodes failed within 1.second

You will always see your own writes. For example if you send two Update messages changing the value of the same key, the modify function of the second message will see the change that was performed by the first Update message.

In the Update message you can pass an optional request context, which the Replicator does not care about, but is included in the reply messages. This is a convenient way to pass contextual information (e.g. original sender) without having to use ask or maintain local correlation data structures.

implicit val node = Cluster(system) val replicator = DistributedData(system).replicator val writeTwo = WriteTo(n = 2, timeout = 3.second) val Counter1Key = PNCounterKey("counter1")

def receive: Receive = { case "increment" => // incoming command to increase the counter val upd = Update(Counter1Key, PNCounter(), writeTwo, request = Some(sender()))(_ replicator ! upd

case UpdateSuccess(Counter1Key, Some(replyTo: ActorRef)) =>

replyTo ! "ack" case UpdateTimeout(Counter1Key, Some(replyTo: ActorRef)) => replyTo ! "nack"

}

+ 1)

Get

To retrieve the current value of a data you send Replicator.Get message to the Replicator. You supply a consistency level which has the following meaning:

• ReadLocal the value will only be read from the local replica

5.8. Distributed Data

288 Akka Scala Documentation, Release 2.4.1

• ReadFrom(n) the value will be read and merged from n replicas, including the local replica

• ReadMajority the value will be read and merged from a majority of replicas, i.e. at least N/2 + 1 replicas, where N is the number of nodes in the cluster (or cluster role group)

• ReadAll the value will be read and merged from all nodes in the cluster (or all nodes in the cluster role group)

val replicator = DistributedData(system).replicator val Counter1Key = PNCounterKey("counter1") val Set1Key = GSetKey[String]("set1") val Set2Key = ORSetKey[String]("set2") val ActiveFlagKey = FlagKey("active")

replicator ! Get(Counter1Key, ReadLocal)

val readFrom3 = ReadFrom(n = 3, timeout = 1.second) replicator ! Get(Set1Key, readFrom3)

val readMajority = ReadMajority(timeout = 5.seconds) replicator ! Get(Set2Key, readMajority)

val readAll = ReadAll(timeout = 5.seconds) replicator ! Get(ActiveFlagKey, readAll)

As reply of the Get a Replicator.GetSuccess is sent to the sender of the Get if the value was successfully retrieved according to the supplied consistency level within the supplied timeout. Otherwise a Replicator.GetFailure is sent. If the key does not exist the reply will be Replicator.NotFound.

case g @ GetSuccess(Counter1Key, req) =>

val value = g.get(Counter1Key).value case NotFound(Counter1Key, req) => // key counter1 does not exist

case g @ GetSuccess(Set1Key, req) =>

val elements = g.get(Set1Key).elements case GetFailure(Set1Key, req) => // read from 3 nodes failed within 1.second case NotFound(Set1Key, req) => // key set1 does not exist

You will always read your own writes. For example if you send a Update message followed by a Get of the same key the Get will retrieve the change that was performed by the preceding Update message. However, the order of the reply messages are not defined, i.e. in the previous example you may receive the GetSuccess before the UpdateSuccess.

In the Get message you can pass an optional request context in the same way as for the Update message, described above. For example the original sender can be passed and replied to after receiving and transforming GetSuccess.

implicit val node = Cluster(system) val replicator = DistributedData(system).replicator val readTwo = ReadFrom(n = 2, timeout = 3.second) val Counter1Key = PNCounterKey("counter1")

def receive: Receive = { case "get-count" => // incoming request to retrieve current value of the counter replicator ! Get(Counter1Key, readTwo, request = Some(sender()))

case g @ GetSuccess(Counter1Key, Some(replyTo: ActorRef)) => val value = g.get(Counter1Key).value.longValue replyTo ! value case GetFailure(Counter1Key, Some(replyTo: ActorRef)) =>

replyTo ! -1L case NotFound(Counter1Key, Some(replyTo: ActorRef)) =>

5.8. Distributed Data

289 Akka Scala Documentation, Release 2.4.1

replyTo ! 0L

}

Consistency

The consistency level that is supplied in the Update and Get specifies per request how many replicas that must respond successfully to a write and read request. For low latency reads you use ReadLocal with the risk of retrieving stale data, i.e. updates from other nodes might not be visible yet. When using WriteLocal the update is only written to the local replica and then disseminated in the background with the gossip protocol, which can take few seconds to spread to all nodes. WriteAll and ReadAll is the strongest consistency level, but also the slowest and with lowest availability. For example, it is enough that one node is unavailable for a Get request and you will not receive the value. If consistency is important, you can ensure that a read always reflects the most recent write by using the following formula:

(nodes_written + nodes_read) > N

where N is the total number of nodes in the cluster, or the number of nodes with the role that is used for the Replicator. For example, in a 7 node cluster this these consistency properties are achieved by writing to 4 nodes and reading from 4 nodes, or writing to 5 nodes and reading from 3 nodes. By combining WriteMajority and ReadMajority levels a read always reflects the most recent write. The Replicator writes and reads to a majority of replicas, i.e. N / 2 + 1. For example, in a 5 node cluster it writes to 3 nodes and reads from 3 nodes. In a 6 node cluster it writes to 4 nodes and reads from 4 nodes. Here is an example of using WriteMajority and ReadMajority:

private val timeout = 3.seconds private val readMajority = ReadMajority(timeout) private val writeMajority = WriteMajority(timeout)

def receiveGetCart: Receive = { case GetCart ⇒ replicator ! Get(DataKey, readMajority, Some(sender()))

case g @ GetSuccess(DataKey, Some(replyTo: ActorRef)) ⇒ val data = g.get(DataKey) val cart = Cart(data.entries.values.toSet) replyTo ! cart

case NotFound(DataKey, Some(replyTo: ActorRef)) ⇒ replyTo ! Cart(Set.empty)

case GetFailure(DataKey, Some(replyTo: ActorRef)) ⇒ // ReadMajority failure, try again with local read replicator ! Get(DataKey, ReadLocal, Some(replyTo))

}

def receiveAddItem: Receive = { case cmd @ AddItem(item) ⇒ val update = Update(DataKey, LWWMap.empty[LineItem], writeMajority, Some(cmd)) {

cart ⇒ updateCart(cart, item) } replicator ! update }

5.8. Distributed Data

290 Akka Scala Documentation, Release 2.4.1

In some rare cases, when performing an Update it is needed to first try to fetch latest data from other nodes. That can be done by first sending a Get with ReadMajority and then continue with the Update when the GetSuccess, GetFailure or NotFound reply is received. This might be needed when you need to base a decision on latest information or when removing entries from ORSet or ORMap. If an entry is added to an ORSet or ORMap from one node and removed from another node the entry will only be removed if the added entry is visible on the node where the removal is performed (hence the name observed-removed set).

The following example illustrates how to do that:

def receiveRemoveItem: Receive = { case cmd @ RemoveItem(productId) ⇒ // Try to fetch latest from a majority of nodes first, since ORMap // remove must have seen the item to be able to remove it. replicator ! Get(DataKey, readMajority, Some(cmd))

case GetSuccess(DataKey, Some(RemoveItem(productId))) ⇒ replicator ! Update(DataKey, LWWMap(), writeMajority, None) {

_ - productId }

case GetFailure(DataKey, Some(RemoveItem(productId))) ⇒ // ReadMajority failed, fall back to best effort local value replicator ! Update(DataKey, LWWMap(), writeMajority, None) {

_ - productId }

case NotFound(DataKey, Some(RemoveItem(productId))) ⇒ // nothing to remove

}

Warning: Caveat: Even if you use WriteMajority and ReadMajority there is small risk that you may read stale data if the cluster membership has changed between the Update and the Get. For example, in cluster of 5 nodes when you Update and that change is written to 3 nodes: n1, n2, n3. Then 2 more nodes are added and a Get request is reading from 4 nodes, which happens to be n4, n5, n6, n7, i.e. the value on n1, n2, n3 is not seen in the response of the Get request.

Subscribe

You may also register interest in change notifications by sending Replicator.Subscribe mes- sage to the Replicator. It will send Replicator.Changed messages to the registered sub- scriber when the data for the subscribed key is updated. Subscribers will be notified periodically with the configured notify-subscribers-interval, and it is also possible to send an explicit Replicator.FlushChanges message to the Replicator to notify the subscribers immediately.

The subscriber is automatically removed if the subscriber is terminated. A subscriber can also be deregistered with the Replicator.Unsubscribe message.

val replicator = DistributedData(system).replicator val Counter1Key = PNCounterKey("counter1") // subscribe to changes of the Counter1Key value replicator ! Subscribe(Counter1Key, self) var currentValue = BigInt(0)

def receive: Receive = { case c @ Changed(Counter1Key) =>

currentValue = c.get(Counter1Key).value case "get-count" => // incoming request to retrieve current value of the counter sender() ! currentValue }

5.8. Distributed Data

291 Akka Scala Documentation, Release 2.4.1

Delete

A data entry can be deleted by sending a Replicator.Delete message to the local local Replicator. As reply of the Delete a Replicator.DeleteSuccess is sent to the sender of the Delete if the value was successfully deleted according to the supplied consistency level within the supplied timeout. Otherwise a Replicator.ReplicationDeleteFailure is sent. Note that ReplicationDeleteFailure does not mean that the delete completely failed or was rolled back. It may still have been replicated to some nodes, and may eventually be replicated to all nodes.

A deleted key cannot be reused again, but it is still recommended to delete unused data entries because that reduces the replication overhead when new nodes join the cluster. Subsequent Delete, Update and Get requests will be replied with Replicator.DataDeleted. Subscribers will receive Replicator.DataDeleted.

val replicator = DistributedData(system).replicator val Counter1Key = PNCounterKey("counter1") val Set2Key = ORSetKey[String]("set2")

replicator ! Delete(Counter1Key, WriteLocal)

val writeMajority = WriteMajority(timeout = 5.seconds) replicator ! Delete(Set2Key, writeMajority)

5.8.2 Data Types

The data types must be convergent (stateful) CRDTs and implement the ReplicatedData trait, i.e. they provide a monotonic merge function and the state changes always converge.

You can use your own custom ReplicatedData types, and several types are provided by this package, such as:

• Counters: GCounter, PNCounter

• Sets: GSet, ORSet

• Maps: ORMap, ORMultiMap, LWWMap, PNCounterMap • Registers: LWWRegister, Flag

Counters

GCounter is a “grow only counter”. It only supports increments, no decrements. It works in a similar way as a vector clock. It keeps track of one counter per node and the total value is the sum of these counters. The merge is implemented by taking the maximum count for each node.

If you need both increments and decrements you can use the PNCounter (positive/negative counter).

It is tracking the increments (P) separate from the decrements (N). Both P and N are represented as two internal GCounter. Merge is handled by merging the internal P and N counters. The value of the counter is the value of the P counter minus the value of the N counter.

implicit val node = Cluster(system) val c0 = PNCounter.empty val c1 = c0 + 1 val c2 = c1 + 7 val c3: PNCounter = c2 - 2 println(c3.value) // 6

Several related counters can be managed in a map with the PNCounterMap data type. When the counters are placed in a PNCounterMap as opposed to placing them as separate top level values they are guaranteed to be replicated together as one unit, which is sometimes necessary for related data.

5.8. Distributed Data

292 Akka Scala Documentation, Release 2.4.1

implicit val node = Cluster(system) val m0 = PNCounterMap.empty val m1 = m0.increment("a", 7) val m2 = m1.decrement("a", 2) val m3 = m2.increment("b", 1) println(m3.get("a")) // 5 m3.entries.foreach { case (key, value) => println(s"$key -> $value") }

Sets

If you only need to add elements to a set and not remove elements the GSet (grow-only set) is the data type to use. The elements can be any type of values that can be serialized. Merge is simply the union of the two sets.

val s0 = GSet.empty[String] val s1 = s0 + "a" val s2 = s1 + "b" + "c" if (s2.contains("a")) println(s2.elements) // a, b, c

If you need add and remove operations you should use the ORSet (observed-remove set). Elements can be added and removed any number of times. If an element is concurrently added and removed, the add will win. You cannot remove an element that you have not seen.

The ORSet has a version vector that is incremented when an element is added to the set. The version for the node that added the element is also tracked for each element in a so called “birth dot”. The version vector and the dots are used by the merge function to track causality of the operations and resolve concurrent updates.

implicit val node = Cluster(system) val s0 = ORSet.empty[String] val s1 = s0 + "a" val s2 = s1 + "b" val s3 = s2 - "a" println(s3.elements) // b

Maps

ORMap (observed-remove map) is a map with String keys and the values are ReplicatedData types them- selves. It supports add, remove and delete any number of times for a map entry.

If an entry is concurrently added and removed, the add will win. You cannot remove an entry that you have not seen. This is the same semantics as for the ORSet.

If an entry is concurrently updated to different values the values will be merged, hence the requirement that the values must be ReplicatedData types.

It is rather inconvenient to use the ORMap directly since it does not expose specific types of the values. The ORMap is intended as a low level tool for building more specific maps, such as the following specialized maps.

ORMultiMap (observed-remove multi-map) is a multi-map implementation that wraps an ORMap with an ORSet for the map’s value.

PNCounterMap (positive negative counter map) is a map of named counters. It is a specialized ORMap with PNCounter values.

LWWMap (last writer wins map) is a specialized ORMap with LWWRegister (last writer wins register) values.

implicit val node = Cluster(system) val m0 = ORMultiMap.empty[Int] val m1 = m0 + ("a" -> Set(1, 2, 3)) val m2 = m1.addBinding("a", 4) val m3 = m2.removeBinding("a", 2)

# unreachable, so it should be configured to worst case in a healthy cluster. max-pruning-dissemination = 60 s

# Serialized Write and Read messages are cached when they are sent to # several nodes. If no further activity they are removed from the cache # after this duration. serializer-cache-time-to-live = 10s

}

