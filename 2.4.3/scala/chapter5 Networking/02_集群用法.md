＃集群用法
有关Akka群集概念的介绍，请参阅群集规范。
Akka Cluster的概念相关的说明请参见上一节。

## 5.2.1准备项目以进行群集

Akka集群是一个单独的jar文件。确保您在项目中具有以下依赖项：

```
com.typesafe.akka”%%“akka-cluster”％“2.4.1”
```

增加依赖

## 5.2.2简单集群示例

以下配置允许使用群集扩展。它加入集群，actor订阅集群成员资格事件并记录它们。 application.conf配置如下所示：

```conf
akka {
actor {
provider =“akka.cluster.ClusterActorRefProvider”
}}
remote {
log-remote-lifecycle-events = off
netty.tcp {
hostname =“127.0.0.1”
port = 0
}}
}}

集群{
种子节点= [
“akka.tcp：//ClusterSystem@127.0.0.1：2551”，
“akka.tcp：//ClusterSystem@127.0.0.1：2552”
]]
auto-down-unreachable-after = 10s
}}
}}

＃禁用akka集群中的旧指标。 akka.cluster.metrics.enabled = off

＃在akka-cluster-metrics中启用度量扩展。 akka.extensions = [“akka.cluster.metrics.ClusterMetricsExtension”]

＃Sigar本地库提取测试期间的位置。 ＃注意：在一台主机上运行多个jvm时，请使用per-jvm-instance文件夹。 akka.cluster.metrics.native-library-extract-folder = $ {user.dir} / target / native
```

要在Akka项目中启用群集功能，您应该至少添加Remoting设置，但使用** akka.cluster.ClusterActorRefProvider **。 ** akka.cluster.seed-nodes **通常也应该添加到你的`application.conf`文件中。

为了在你的应用中启用集群能力，你至少要配置XXX和XXX

>注意：如果您使用Docker或由于某些其他原因的节点具有单独的内部和外部IP地址，则必须根据NAT和Docker的远程配置来配置远程处理

种子节点是用于初始，自动，加入集群的联系点。

配置种子节点用于集群中其它节点的初始化，自动化，加入。

注意，如果要在不同的计算机上启动节点，则需要在application.conf中指定机器的ip地址或主机名，而不是127.0.0.1

使用集群扩展的actor可能如下所示：

```scala
package sample.cluster.simple

导入akka.cluster.Cluster
导入akka.cluster.ClusterEvent._
import akka.actor.ActorLogging
导入akka.actor.Actor

class SimpleClusterListener extends Actor with ActorLogging {

val cluster = Cluster（context.system）

//订阅集群更改，重新启动时重新订阅
override def preStart（）：Unit = {
//＃订阅
cluster.subscribe（self，initialStateMode = InitialStateAsEvents，classOf [MemberEvent]，classOf [UnreachableMember]）
//＃订阅
}}

override def postStop（）：Unit = cluster.unsubscribe（self）

def receive = {
case MemberUp（member）=>
log.info（“Member is Up：{}”，member.address）
case UnreachableMember（member）=>
log.info（“Member detected as unreachable：{}”，member）
case MemberRemoved（member，previousStatus）=>
log.info（“Member is Removed：{} after {}”，member.address，previousStatus）
case _：MemberEvent => // ignore
}}
}}
```

该actor将自己注册为某些集群事件的订阅者。当订阅开始时，它接收与群集的当前状态相对应的事件，然后它接收在群集中发生的改变的事件。
这个actor把自己注册为一个订阅者。它会根据集群当前的状态接收相应的消息
运行这个例子的最简单的方法是下载Typesafe Activator并打开名为Akka Cluster Samples with Scala的教程。它包含如何运行SimpleClusterApp的说明。

## 5.2.3加入种子节点

您可以决定是否应手动或自动完成加入集群的配置初始接触点，即所谓的种子节点。当新节点启动时，它向所有种子节点发送消息，然后将join命令发送到首先回答的节点。如果没有其中一个种子节点回复（可能尚未启动），它将重试此过程，直到成功或关闭。

您在配置文件（application.conf）中定义种子节点：

```yaml
akka.cluster.seed-nodes = [
“akka.tcp：// ClusterSystem @ host1：2552”，
“akka.tcp：// ClusterSystem @ host2：2552”
]]
```

在使用以下语法启动JVM时，也可以将其定义为Java系统属性：


```java
-Dakka.cluster.seed-nodes.0 = akka.tcp：// ClusterSystem @ host1：2552
-Dakka.cluster.seed-nodes.1 = akka.tcp：// ClusterSystem @ host2：2552
```

种子节点可以以任何顺序启动，并且没有必要使所有种子节点运行，但是在初始启动集群时必须启动配置为种子节点配置列表中的第一个元素的节点，否则，节点将不会被初始化，并且没有其他节点可以加入集群。特殊的第一种子节点的原因是为了避免在从空簇开始时形成孤岛。最快同时启动所有配置的种子节点（顺序无关紧要），否则可以占用配置的种子节点超时，直到节点可以加入。

种子节点可以以任何顺序启动，而不是必要的所有种子节点上运行，但是节点配置在种子节点的配置列表的第一个元素必须被启动，当开始一个集群，否则其他种子节点不会成为初始化并没有其他节点加入群集。特殊的第一个种子节点的原因是为了避免从一个空的集群开始时间形成分离的岛屿。它是最快的启动所有配置的种子节点在同一时间（顺序不要紧），否则它可以采取的配置的种子节点超时，直到节点可以加入。

一旦超过两个种子节点已经启动，关闭第一种子节点就没有问题。如果第一个种子节点重新启动，它将首先尝试加入现有群集中的其他种子节点。
当超过两个种子节点启动后再关闭头节点就不会有问题了。
如果头节点重启的话，它会加入已有集群。

如果不配置种子节点，则需要以编程方式或手动方式加入集群。

可以通过使用ref：cluster_jmx_scala或命令行管理来执行手动加入。可以使用Cluster(system).join进行程序连接。在配置属性retry-unsuccessful-join-after中定义的时间段后，将自动重试不成功的连接尝试。可以通过将属性设置为关闭来禁用重试。

您可以加入群集中的任何节点。它不必被配置为种子节点。请注意，您只能加入现有集群成员，这意味着要进行引导，某些节点必须自己加入，然后以下节点可以加入它们以组成集群。

您还可以使用Cluster(system).joinSeedNodes以编程方式连接，这在使用某些外部工具或API动态发现启动时的其他节点时非常有吸引力。当使用joinSeedNodes时，除了应该是第一个种子节点的节点之外，您不应该包括节点本身，并且应该首先将其放在joinSeedNodes的参数中。

在配置属性seed-node-timeout中定义的时间段后，将自动重试与种子节点联系的不成功尝试。在配置的retry-unsuccessful-join-after后，将自动重试不成功的尝试加入特定种子节点。重试意味着它尝试联系所有种子节点，然后加入首先回答的节点。如果种子节点列表中的第一个节点不能在配置的种子节点超时内与任何其他种子节点联系，则它将加入自身。

角色系统只能加入一个集群一次。其他尝试将被忽略。当它成功加入时，必须重新启动才能加入另一个集群或再次加入同一个集群。在重新启动后，它可以使用相同的主机名和端口，当它作为集群中现有成员的新的化身，尝试加入，然后现有的将从集群中删除，然后它将被允许加入。

## 5.2.4 自动与手动Downing

当故障检测器认为成员不可达时，不允许领导者执行其职责，例如将新加入的成员的状态改变为“向上”。节点必须首先再次可达，或者不可达成员的状态必须更改为“Down”。将状态更改为“向下”可以自动或手动执行。默认情况下，必须使用JMX或命令行管理手动完成。

它也可以使用Cluster(system).down(address)以编程方式执行。

您可以使用配置启用自动停机：

akka.cluster.auto-down-unreachable-after = 120s

这意味着在配置时间内无法访问之后，集群领导成员将自动将不可达节点状态更改为down。

请注意，使用自动关闭意味着在网络分区的情况下将自动形成两个单独的集群。这可能是某些应用程序需要的，但不是其他应用程序。

注意：如果您已启用自动关闭并且故障检测器触发，则如果您没有采取措施关闭已无法访问的节点，则可能会在一段时间后结束大量单节点集群。这是由于不可达节点将可能看到集群的其余部分不可达，成为其自己的领导者并形成其自己的集群。

## 5.2.5离开

有两种方法可从集群中删除成员。

你可以停止actor系统（或JVM进程）。它将被检测为不可达，并且在如上所述的自动或手动降频之后被移除。

如果你告诉集群节点应该离开，可以执行更优雅的退出。这可以使用JMX或命令行管理来执行。它也可以用编程方式执行：

```
val cluster = Cluster(system)cluster.leave(cluster.selfAddress)
```
请注意，此命令可以发送到集群中的任何成员，不一定是离开的成员。离开成员的集群扩展，而不是actor系统或JVM将在leader将成员的状态更改为Exiting之后关闭。此后，该成员将从群集中删除。通常这是自动处理的，但是在这个过程中的网络故障的情况下，仍然可能需要将节点的状态设置为Down，以完成删除。

## 5.2.6 WeaklyUp会员

如果节点不可达，那么闲话收敛是不可能的，因此任何领导者动作也是不可能的。但是，在这种情况下，我们仍然可能希望新节点加入集群。

警告：WeaklyUp功能在Akka 2.4.0中的介绍中被​​标记为“实验性”。我们将根据用户的反馈继续改进此功能，这意味着尽管我们尝试将不兼容的更改保持为最低限度，但是维护版本的二进制兼容性保证不适用于此功能。

默认情况下禁用此功能。使用配置选项，您可以允许此行为：

```
akka.cluster.allow-weakly-up-members = on
```
当allow-weakly-up-members启用并且没有闲话收敛时，加入成员将被提升为WeaklyUp，并且它们将成为集群的一部分。一旦达到八卦聚会，领导者将把WeaklyUp成员移动到Up。

您可以订阅WeaklyUp成员资格事件，以利用处于此状态的成员，但是您应该意识到网络分区另一端的成员不知道新成员的存在。例如，您不应该计算WeaklyUp成员在法定裁定中的数量。

警告：此功能仅适用于Akka 2.4.0，如果某些群集成员正在运行Akka的旧版本，则无法使用此功能。

## 5.2.7 订阅集群事件

您可以通过使用更改“群集（系统）.subscribe”来订阅群集成员资格的通知。

```scala
cluster.subscribe（self，classOf [MemberEvent]，classOf [UnreachableMember]）
```

完整状态`akka.cluster.ClusterEvent.CurrentClusterState`的快照作为第一条消息发送到订户，随后是增量更新的事件。

请注意，如果在初始连接过程完成之前启动了订阅，您可能会收到一个空的CurrentClusterState，它不包含成员。这是预期的行为。当节点在集群中被接受时，您将接收该节点的MemberUp和其他节点。

如果你发现不方便处理`CurrentClusterState`，你可以使用ClusterEvent.InitialStateAsEvents作为参数来订阅。这意味着，不是接收CurrentClusterState作为第一个消息，您将收到对应于当前状态的模拟如果你在过去发生事件时你会看到的事件。请注意，这些初始事件仅对应于当前状态，并且它不是在集群中实际发生的所有更改的完整历史记录。

```
cluster.subscribe（self，initialStateMode = InitialStateAsEvents，classOf [MemberEvent]，classOf [UnreachableMember]）
```

跟踪成员生命周期的事件有：

•“ClusterEvent.MemberJoined” - 新成员已加入群集，其状态已更改为加入。

•`ClusterEvent.MemberUp`  - 一个新成员已加入集群，其状态已更改为Up。

•“ClusterEvent.MemberExited” - 成员正在离开集群，并且其状态已更改为退出。注意，当此事件在另一个节点上发布时，节点可能已关闭。

•`ClusterEvent.MemberRemoved`  - 成员从集群中完全删除。

•`ClusterEvent.UnreachableMember`  - 成员被认为是不可达的，由至少一个其他节点的故障检测器检测。

•“ClusterEvent.ReachableMember” - 在无法访问之后，会员将再次被视为可访问。之前检测为不可访问的所有节点已检测到它为可再次访问。

有更多类型的更改事件，有关事件的详细信息，请参阅扩展`akka.cluster.ClusterEvent.ClusterDomainEvent`的类的API文档。

而不是订阅集群事件，有时可以方便地只获得与集群（系统）.state的完全成员资格状态。请注意，此状态不一定与发布到群集预订的事件同步。

### 工作人员拨入示例

让我们来看一个例子，说明工作者，这里叫做后端，可以检测和注册到新的主节点，这里命名为frontend。

示例应用程序提供了一种转换文本的服务。当一些文本发送到其中一个前端服务时，它将被委派给一个后端工作者，后者执行转换作业，并将结果发送回原始客户端。可以向集群动态添加或删除新的后端节点以及新的前端节点。

消息：

```scala
final case类TransformationJob（text：String）
final case类TransformationResult（text：String）
final case class JobFailed（reason：String，job：TransformationJob）
case对象BackendRegistration
```
执行转换作业的后端工作：

```scala
class TransformationBackend extends Actor {

val cluster = Cluster（context.system）

//订阅集群更改，MemberUp
//重新启动时重新订阅
override def preStart（）：Unit = cluster.subscribe（self，classOf [MemberUp]）
override def postStop（）：Unit = cluster.unsubscribe（self）

def receive = {
case TransformationJob（text）=>
sender（）！ TransformationResult（text.toUpperCase）
case state：CurrentClusterState =>
state.members.filter（_。status == MemberStatus.Up）foreach register case MemberUp（m）=> register（m）}

def register（member：Member）：Unit =
if（member.hasRole（“frontend”））
context.actorSelection（RootActorPath（member.address）/“user”/“frontend”）！后端注册
}}
```
请注意，TransformationBackend actor订阅集群事件以检测新的，潜在的前端节点，并向其发送注册消息，以便他们知道它们可以使用后端工作线程。

接收用户作业并委派给其中一个注册后端工作人员的前端：

```scala
类TransformationFrontend extends Actor {
var backends = IndexedSeq.empty [ActorRef]
var jobCounter = 0

def receive = {
case job：TransformationJob if backends.isEmpty => sender（）！ JobFailed（“服务不可用，稍后再试”，作业）
case job：TransformationJob => jobCounter + = 1后端（jobCounter％backends.size）转发作业
case backendRegistration if！backends.contains（sender（））=> context watch sender（）backends = backends：+ sender（）
case Terminated（a）=> backends = backends.filterNot（_ == a）
}}
}}
```
请注意，TransformationFrontend actor会监视注册的后端，以便能够从可用的后端工作程序列表中删除它。死亡手表使用集群中的节点的集群故障检测器，即除了正常终止观看的actor之外，它还检测网络故障和JVM崩溃。当不可达的集群节点被关闭和删除时，死亡监视器向监视动作者产生终止消息。

Typesafe激活器教程命名为Akka Cluster Samples with Scala。包含完整的源代码和如何运行Worker Dial-In示例的说明。

## 5.2.8 节点角色

并非集群的所有节点都需要执行相同的功能：可能有一个子集运行Web前端，一个运行数据访问层，一个用于数字处理。演员的部署 - 例如通过集群感知路由器 - 可以考虑节点角色以实现这种责任分配。

节点的角色在名为akka.cluster.roles的配置属性中定义，并且通常在启动脚本中定义为系统属性或环境变量。

节点的角色是您可以订阅的MemberEvent中成员资格信息的一部分。

## 5.2.9如何在启动集群大小时启动

一个常见的用例是在集群初始化，成员加入并且集群已经达到一定大小之后启动actors。

使用配置选项，您可以在领导将“加入”成员的成员状态更改为“上”之前定义所需的成员数。

akka.cluster.min-nr-of-members = 3

以类似的方式，您可以在领导将“加入”成员的成员状态更改为“上”之前定义某个角色的所需成员数。

akka.cluster.role {frontend.min-nr-of-members = 1 backend.min-nr-of-members = 2}

您可以在registerOnMemberUp回调中启动actors，当当前成员状态更改为“Up”时调用，即集群至少具有定义的成员数。

Cluster(system).registerOnMemberUp {system.actorOf（Props（classOf [FactorialFrontend]，upToN，true），name =“factorialFrontend”）}

这个回调可以用于除了启动actors之外的其他事情。

## 5.2.10删除成员时如何清理

您可以在registerOnMemberRemoved回调中进行一些清理，当当前成员状态更改为“已删除”或群集已关闭时，将调用此回调。

例如，这是如何关闭ActorSystem，然后退出JVM：

```scala
Cluster(system).registerOnMemberRemoved {
//当ActorSystem已终止时退出JVM
system.registerOnTermination（System.exit（0））
//关闭ActorSystem
system.terminate（）

//如果ActorSystem关闭所需的时间超过10秒，
//无论如何强制退出JVM。
//我们必须生成一个单独的线程来阻止当前线程，
//因为这将阻止ActorSystem的关闭。
新线程
override def run（）：Unit = {
if（Try（Await.ready（system.whenTerminated，10.seconds））。isFailure）System.exit（-1）}
}。开始（）
}}
```
>注意：在已经关闭的集群上注册OnMemberRemoved回调，回调将立即在调用程序线程上调用，否则将在当前成员状态更改为“已删除”时调用。您可能需要在群集启动后安装一些清理处理，但是在安装时群集可能已经关闭，并且根据种族不健康。

## 5.2.11 Cluster Singleton

对于一些使用情况，它是方便的，有时也是强制性的，以确保您有一个特定类型的某个actor运行在集群中的某个地方。

这可以通过订阅成员事件来实现，但是有几种情况需要考虑。因此，这个特定的用例是由Cluster Singleton容易访问的。

## 5.2.12集群分片

在集群中的多个节点上分布actor，并且使用它们的逻辑标识符支持与actors的交互，但不必关心它们在集群中的物理位置。

请参阅群集分片

## 5.2.13分布式发布订阅

在集群中的演员之间发布订阅消息传递以及使用演员的逻辑路径的点对点消息传递，即发送者不必知道目的地actor在哪个节点上运行。

请参阅群集中的分布式发布预订。

## 5.2.14集群客户端

从不是群集一部分的actor系统到在群集中某处运行的actor的通信。客户端不必知道目标actor在哪个节点上运行。

请参阅集群客户端。

###群集分派器

在引擎盖下，集群扩展由演员实现，并且可能需要为那些演员创建一个舱壁，以避免来自其他演员的干扰。特别地，用于故障检测的心跳主体可以在没有给定机会以规律的间隔运行的情况下产生假阳性。为此，您可以定义要用于集群actors的单独的分派器：

```conf
akka.cluster.use-dispatcher = cluster-dispatcher

cluster-dispatcher {
	type =“Dispatcher”
	executor =“fork-join-executor”
	fork-join-executor {
		parallelism-min = 2
		parallelism-max = 4
		}}
	}
}
```

